<script lang=ts>
  import { onMount } from 'svelte'
  import type { Feedback } from '@txstate-mws/svelte-forms'
  import { FieldMultiple, FieldNumber, FieldSelect, FieldText, Form } from '@dosgato/dialog'
  import type { DraftResult, RawJsonResult } from '$lib/models/result.js'
  import type { PopupMenuItem } from '@txstate-mws/svelte-components'
  import { isBlank } from 'txstate-utils'
  import { apiBase } from '$lib/util/globals'

  // Maybe spiff up the page adding enhance to the forms and adding these transitions.
  // Might need to add to the form library or custom rebuild it here with them.
  // import { enhance } from '$app/forms'
  // Example: <form .... use:enhance ... >
  // import { fly, slide } from 'svelte/transition'
  // Example: <li in:fly={{ y: 20 }} out:slide>

  export let data: DraftResult | undefined

  async function removeEntry (id: string) {
    // Remove entry's elements from AddMore element in DOM possibly needing to call
    // its API or interact via its two-way binds. Ensure it's reliably handling destroy.
  }

  /**
  ```ts
  {
    url: string
    title: string
    id?: string
    entries: {
      keyphrase: string
      mode: 'keyword'|'phrase'|'exact'
      priority: number
    }[]
    tags?: string[]
    priority?: number
  }
  ``` */
  interface ResultState extends RawJsonResult {
    /** IDs are generated by Mongo/Mongoose and this serves as a placeholder when passed a list of
    entries to populate the form's entries section with for editing. */
    id?: string
  }

  async function submit (state: ResultState) {
    console.log('POST:', JSON.stringify(state))
    const resp = await fetch(`${apiBase}/result`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(state)
    })
    console.log('RESP:', JSON.stringify(resp))
    // const messages: Feedback[] = []
    return resp
  }

  function validate (state: ResultState): Feedback[] {
    const messages: Feedback[] = []
    if (isBlank(state.url)) messages.push({ type: 'error', message: 'Must include a URL to associate Result with.' })
    if (isBlank(state.title)) messages.push({ type: 'warning', message: 'A Title to associate with the URL would be helpful.' })
    if (!state.entries.length) messages.push({ type: 'error', message: 'Please add search aliases to associate with this result.' })
    return messages
  }
  const modeDescriptions = `
  The type of matching to perform:<br>
  <dl>
    <dt>Exact</dt><dd>The words here must match exactly with the search.</dd>
    <dt>Phrase</dt><dd>All words here must be present in the search in the same order as listed here.</dd>
    <dt>Keyword</dt><dd>All words here must be preset in the search in any order.</dd>
  </dl>
  `
  const choices: PopupMenuItem[] = [
    { value: 'keyword', label: 'Keyword' },
    { value: 'phrase', label: 'Phrase' },
    { value: 'exact', label: 'Exact' }
  ]

  function isInitialized () { return !!true }
  onMount(() => {
    if (data?.id) { console.log('TODO: (Optional) ResultEditor - Race Condition Check Interval') }
    /* Add interval to check for race condition updates to result/[id] and display them to active user.
       Keep in mind that upserts to the Result model already do some checking at .save but it'd be nice
       notify our user that someone else is working on the same Result and what changes they've saved.
       - OR don't waste all the electricity making service calls they can coordinate themselves with so
       few users. */
  })
  const preload = { title: 'HomePage', url: 'https://www.txstate.edu/', entries: [{ keyphrase: 'Texas State', mode: 'keyword', priority: 50 }] }
</script>

<Form name='result' {submit} {validate} {preload} let:saved>
  <div class='result-form'>
    <FieldText path='title' label='Title:' defaultValue={data?.title ?? ''}/>
    <FieldText path="url" label='URL:' defaultValue={data?.url ?? ''}/>
    <FieldMultiple path="entries" label="Matching Aliases:" removable={true} let:index >
      <div class='result-entries-form'>
        <!-- Consider replacing the below with another construct of the fields. -->
        <FieldText path="keyphrase" label='Keyphrase:' defaultValue={data?.entries[index].keyphrase ?? ''}/>
        <FieldSelect path="mode" label='Mode:' defaultValue={data?.entries[index].mode ?? 'keyword'} helptext={modeDescriptions} {choices} />
        <FieldNumber path="priority" label='Priority:' defaultValue={data?.entries[index].priority ?? 0} step={10} />
      </div>
    </FieldMultiple>
    <FieldText path="tags" label='Tags:' defaultValue={data?.tags?.join(' ') ?? ''}/>
  </div>
  <svelte:fragment slot="submit" let:saved>
    <button>Save</button>
    {#if saved}Save successful!{/if}
  </svelte:fragment>
</Form>

<style>
  :focus {
    outline: 3px solid #005481;
  }

  :global(dl) {
    margin: 0;
    padding: 0;
    display: flex;
    flex-flow: row wrap;
  }

  :global(dt:before) {
    content: "";
    display: block;
  }
  :global(dt) {
    flex-basis: 20%;
    padding: 2px 4px;
    text-align: right;
    font-weight: bold;
  }
  :global(dt:after) {
    content: ":";
  }
  :global(dd) {
    flex-basis: 70%;
    flex-grow: 1;
    margin: 0;
    padding: 2px 4px;
    text-align: left;
    margin-left: auto;
  }
</style>
