<script lang='ts' context='module'>
  import type { TemplateResult, RawJsonResult, ResultFull, ResultEntry } from '$lib/models/result.js'
  import type { PopupMenuItem } from '@txstate-mws/svelte-components'
  import { MessageType, type Feedback, type FormStore, type SubmitResponse } from '@txstate-mws/svelte-forms'
  import FeedbackLinks from './FeedbackLinks.svelte'
  import { VALIDATE_ONLY, apiURL, appURL } from '$lib/util/globals'
  import { isValidHttpUrl, normalizeUrl } from '$lib/util/helpers'
  import { FieldHidden, FieldNumber, FieldSelect, FieldStandard, FieldText, Form, Icon, Input } from '@dosgato/dialog'
  import FieldMultiple from './FieldMultiple.svelte'
  // import helpCircle from '@iconify-icons/mdi/help-circle'
  import deleteCircle from '@iconify-icons/mdi/delete'
  import { beforeNavigate, goto } from '$app/navigation'

  // Used for extracting values used by FeedbackLinks to build links to other records.
  const equivUrlsRegex = /^equivalent\.url\.(?<id>[^.]*)\.(?<title>.*)/
  const equivTitlesRegex = /^equivalent\.title\.(?<id>[^.]*)\.(?<title>.*)/
  const savedRegex = /^save\.(?<id>[^.]*)\.(?<title>.*)/

  /**
  ```ts
  {
    url: string
    title: string
    id?: string
    entries: {
      keyphrase: string
      mode: 'keyword'|'phrase'|'exact'
      priority: number
    }[]
    tags?: string[]
  }
  ``` */
  interface ResultState extends RawJsonResult {
    /** IDs are generated by Mongo/Mongoose and this serves as a placeholder when passed a list of
    entries to populate the form's entries section with for editing. */
    id?: string
  }
  const choices: PopupMenuItem[] = [
    { value: 'keyword', label: 'Keyword' },
    { value: 'phrase', label: 'Phrase' },
    { value: 'exact', label: 'Exact' }
  ]

  const keyphraseTooltip = 'The word, words, or phrase to find in the query.'
  const modeTooltip = `The type of matching to perform:
  Exact - Terms must exactly match the query.
  Phrase - Terms must be present in the query in the same order as here.
  Keyword - Terms must be present in the query in any order.`
  const priorityTooltip = 'Use a weight scale where 1 represents the lowest priority, 100 represents the highest priority, and reserve greater than 100 or less than 0 for extremely exceptional situations.'
</script>
<script lang='ts'>
  /* TODO:
    1) Look into CSS nesting with (this is very low priority for now)
    OR Ignore below and just use SCSS.
      a) different CSS attribute selectors.
        Examples:
        - div[class~='classname'] - for 'classname' being any one of the space separated words in class attribute.
        - div[class|='classname'] - for class value starts with 'classname' optionally followed by hyphenated classname extensions `-.*`
        - div[class*='classname'] - for 'classname' being a substring contained anywhere in the class attribute.
      b) :has(), :is(), and :where() psuedo-selectors.
        Examples:
        - :global(.class1:not(:has(.subclass))) - For making clearer structure refrences.
        - :global(:is(.class1, .class2)) - For grouping common rules with most-specific specificity.
        - :global(:where(.class1, .class2)) - For grouping common rules with zero specificity.
  */
  import { afterUpdate } from 'svelte'

  /** A `TemplateResult` compatible object to preload the editor form with. */
  export let data: TemplateResult | undefined
  /** The API endpoint and method to submit the form data to. */
  export let apiTarget: { url: string, method: string } = { url: `${apiURL}/result`, method: 'POST' }

  const preload = data ?? {
    title: undefined,
    url: 'https://',
    entries: [
      { keyphrase: undefined, mode: 'keyword', priority: undefined }
    ]
  }

  let store: FormStore<ResultState>
  let tagsInputElement: HTMLInputElement = undefined as any

  /** Used to capture if we need to reset resultId for the context of the Delete button being shown.
   * Normally we'd be fine with the reactive statements below as a simple assignment between data.id
   * and store.id but on create forms we start without a data.id and only get one after a successful
   * save returns one. However, the store keeps that ID and we need a means of catching if we need
   * to clear it outside the submit callback which doesn't have a means of unsetting the value without
   * the FormStore setting it right back. */
  let doIdReset = false
  async function submit (state: ResultState): Promise<SubmitResponse<ResultState>> {
    doIdReset = !!(!data?.id && state.id)
    const resp = await (await fetch(`${apiTarget.url}`, { method: apiTarget.method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(state) })).json()
    const messages: Feedback[] = resp.messages ?? []
    if (messages.some(m => m.type === MessageType.ERROR)) {
      return { success: false, data: state, messages }
    }
    // For some reason the store doesn't always clear the dirtyFields on successful submit so we're forcing it here.
    store.dirtyFields.clear()
    return { success: true, data: resp.result, messages }
  }

  async function validate (state: ResultState): Promise<Feedback[]> {
    // Make sure the URL is lowercased on case-insensitive portions so we can be sure to catch duplicates.
    state.url = state.url.trim()
    const normalized = isValidHttpUrl(state.url) ? normalizeUrl(state.url) : undefined
    if (normalized) {
      const newURL = state.url.endsWith('/') ? normalized : normalized.replace(/\/$/, '')
      if (newURL !== state.url) {
        state.url = newURL
        await store.setField('url', newURL)
      }
    }
    const resp = await (await fetch(`${apiTarget.url}?${VALIDATE_ONLY}`, {
      method: apiTarget.method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(state)
    })).json() as ({ result: Partial<ResultFull>, messages: Feedback[] } | { message: string })
    /* For some reason the auto-validate first call to /result POST doens't have values for login.
     * Check for that response and don't validate further else we'll get all sorts of errors trying
     * to work with properties of undefined parents that the API didn't return because its first call
     * might not have thought we were logged in - May be a dev env only thing. */
    const thrownResp = resp as { message: string }
    if (thrownResp.message && thrownResp.message === 'Error: 403') {
      return [{ type: MessageType.WARNING, path: 'login', message: 'API was not able to identify you.' }]
    }
    const processedResp = resp as { result: Partial<ResultFull>, messages: Feedback[] }
    const messages: Feedback[] = processedResp.messages ?? []
    // Translate message paths to match our store's paths.
    return messages.map(m => ({ ...m, path: m.path?.replace(/keywords/, 'keyphrase') }))
  }

  function tagsSerialize (value: string[]) {
    return value?.join(' ') ?? ''
  }
  function tagsDeserialize (value: string) {
    return value?.split(/[, ]/) ?? []
  }

  let deleting = false
  async function handleDelete () {
    const confirmed = window.confirm('Are you sure you want to delete this record and go back to the home screen?')
    if (confirmed) {
      const resp = await (await fetch(`${apiURL}/result/${resultId}`, { method: 'DELETE' })).json()
      if (resp.ok) {
        window.alert('Successfully deleted record.')
        deleting = true
        await goto('/admin')
        deleting = false
      } else window.alert('Failed to delete record.')
    }
  }
  beforeNavigate(({ to, from, cancel }) => {
    const dirtyFields = Array.from(store.dirtyFields.entries())
    if (dirtyFields.length && !deleting) {
      const confirmed = window.confirm('You have unsaved changes. Are you sure you want to leave?')
      // const confirmed = window.confirm('You are about to exit without saving your work. Would you like to continue?')
      if (!confirmed) cancel()
    }
  })
  afterUpdate(() => {
    if (doIdReset) {
      $store.data.id = undefined
    }
  })
  function deleteMatchingConfirm (item: ResultEntry) {
    return `Are you sure you want to delete "${item.keyphrase}"?`
  }
  $: submitContext = data?.id ? 'Update' : 'Create'
  $: resultId = doIdReset ? data?.id : data?.id ?? $store?.data?.id
</script>
<!--
  @component
  TODO: Add reference description for component that's displayed in VSCode editors.
-->
<Form bind:store name='result' {submit} {validate} {preload} let:saved let:messages>
  <div class='result-form'>
    <FieldText path='title' label='Display Title:' defaultValue={''} required/>
    <FeedbackLinks data={messages} path={equivTitlesRegex} targetURL={`${appURL}/results/`} pathKeys={['id', 'title']}
      buildPath={(found, keys) => found.id} preamble='Edit ' getText={(found, keys) => found.title} postscript="'s record."/>
    <FieldText path='url' label='Target URL:' defaultValue={'https://'} required />
    <FeedbackLinks data={messages} path={equivUrlsRegex} targetURL={`${appURL}/results/`} pathKeys={['id', 'title']}
      buildPath={(found, keys) => found.id} preamble='Edit ' getText={(found, keys) => found.title} postscript="'s record."/>
    <!-- svelte-forms(entries[]) -->
    <div class='result-entries'>
      <!--
      <div class='label-with-helpicon'>
        <label for={'alias-help'}>Matching Aliases</label>
        <button id='alias-help' type='button' on:click|preventDefault|stopPropagation={openHelp}>
          <Icon icon={helpCircle} hiddenLabel='documentation on search result aliases'/>
        </button>
      </div>
      -->
      <FieldMultiple path='entries' label='Matchings' helptext='' removable={true} confirmDelete={deleteMatchingConfirm} let:index>
        <div class='result-entries-record'>
          <span data-tooltip={keyphraseTooltip} class={index === 0 ? 'tooltip-shown tooltipped' : 'tooltipped'}>
            <FieldText path='keyphrase' label='Terms:' defaultValue={''} required />
          </span>
          <span data-tooltip={modeTooltip} class={index === 0 ? 'tooltip-shown tooltipped' : 'tooltipped'}>
            <FieldSelect path='mode' label='Type:' notNull defaultValue={'keyword'} {choices} required />
          </span>
          <span data-tooltip={priorityTooltip} class={index === 0 ? 'tooltip-shown tooltipped' : 'tooltipped'}>
            <FieldNumber path='priority' label='Weight:' defaultValue={50} required/>
          </span>
        </div>
        <Icon slot='removeBtnIcon' icon={deleteCircle} hiddenLabel='remove from list'/>
      </FieldMultiple>
    </div>
    <FieldStandard path='tags' label='Administrative Tags:' defaultValue={''} serialize={tagsSerialize} deserialize={tagsDeserialize} let:value let:valid let:invalid let:id let:onBlur let:onChange let:messagesid let:helptextid>
      <Input bind:inputelement={tagsInputElement} name='tags' {value} {id} class="dialog-input" {onChange} {onBlur} {valid} {invalid} {messagesid} {helptextid} ></Input>
    </FieldStandard>
  </div>
  {#if resultId}<FieldHidden path='id' bind:value={resultId}/>{/if}
  <svelte:fragment slot='submit' let:saved let:submitting let:validating let:valid let:allMessages>
    <div class='record-action-buttons'>
      <button on:click class='submit-button' style={`--submit-context: '${submitContext === 'Create' ? 'Use as Template' : 'Update'}';`}
        class:validating class:submitting class:saved type='submit' disabled={!valid}>
        {#if submitting}Submitting...
        {:else if validating}Validating...
        {:else if saved}<span></span>
        {:else}{submitContext}
        {/if}
      </button>
      <!-- Not really sure how to make providing such a link look good. Would be nice to put it in the form messages but the padding
           around them makes the spacing too much.
      {#if saved && submitContext === 'Create'}
        <FeedbackLinks data={allMessages} path={savedRegex} targetURL={`${appURL}/results/`} pathKeys={['id', 'title']}
          buildPath={(found, keys) => found.id} preamble='Edit ' getText={(found, keys) => found.title} postscript="'s record."/>
      {/if}
      -->
      {#if resultId}
        <button on:click={handleDelete} class='submit-button' style="--submit-context: 'Delete';" type='button'>Delete</button>
      {/if}
    </div>
  </svelte:fragment>
</Form>

<!-- <style lang="scss"> TODO: I need to get back to translating the below to scss. Lower priority right now. -->
<style>
  .record-action-buttons {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
  }
  .tooltipped {
    position: relative;
  }
  .tooltip-shown::before { /* Text */
    content: attr(data-tooltip);
    text-align: center;
    font-size: 0.9rem;
    white-space: pre-wrap;
    width: max-content;
    max-width: 200%;
    --scale: 0;
    position: absolute;
    top: -.25rem;
    left: -3rem;
    transform: translateX(-1rem) translateY(-90%) scale(var(--scale));
    transition: 10ms transform ease-in;
    transform-origin: bottom center;
    padding: 0.2rem 0.5rem;
    /* border: .25rem solid transparent; */
    border-radius: .3rem;
    background-color: var(--colors-help);
    color: var(--colors-help-text);
    z-index: 1;
  }
  .tooltip-shown:first-child::before {
    left: 0;
    transform: translateX(-.5rem) translateY(-90%) scale(var(--scale));
  }
  .tooltip-shown:nth-child(2)::before {
    text-align: left;
    left: -7rem;
    max-width: 300%;
  }
  .tooltip-shown:hover::before {
    --scale: 1;
  }
  .submit-button.saved > span::after {
    content: 'Successful!';
    animation: replace normal forwards 10s;
  }
  @keyframes replace {
    to { content: var(--submit-context); }
  }
  .result-form {
    --entries-multiple-spacing: 1.0rem;/*var(--element-container-spacing);   They liked 1.5rem. */
    --padding-between-borders-and-first-container: calc(var(--entries-multiple-spacing) - 0.3rem);
    --padding-between-last-container-and-borders: var(--entries-multiple-spacing);
    --margin-below-borders-and-buttons: calc(var(--margin-below-labels) + 0.1rem);
    --container-borders: 1px solid black;
    --delete-button-offset: 1.3rem;
    --delete-button-top: calc(var(--entries-multiple-spacing) + var(--delete-button-offset));
    --help-icon-size: 0.7rem;
    --border-to-label-spacing: 0.8rem;
    & > div:not(.result-entries) {
      border: none !important;
    }
    & > div:last-of-type {
      margin-bottom: var(--element-container-spacing);
    }
  }
  .result-form :global(.dialog-multiple) {
    --dialog-container-border: none;
    border: none;
  }
  /* All form containers except those nested under result-entries. */
  .result-form :global(.dialog-field-container:not(.result-entries *)) {
    padding: 0 !important;
    margin-top: var(--element-container-spacing);
    & > label {
      margin-bottom: var(--margin-below-labels);
    }
  }
  .result-entries {
    margin-top: var(--element-container-spacing);
    border-top: var(--container-borders);
    padding-top: var(--border-to-label-spacing);
    padding-bottom: var(--element-container-spacing);
    border-bottom: var(--container-borders);
  }
  /* .label-with-helpicon {
    & > label {
      display: inline-block;
      padding-right: 0;
      margin-bottom: var(--margin-below-labels);
    }
    & > button {
      border: none;
      background: transparent;
      padding: 0;
      cursor: pointer;
      font-size: 1.3rem;
    }
  }
  .label-with-helpicon > button :global(svg) {
    display: inline-block;
    box-sizing: border-box;
    width: var(--help-icon-size);
    height: var(--help-icon-size);
    color: var(--colors-help);
  } */
  .result-entries :global(.dialog-field-container) {
    padding: 0 !important;
  }
  .result-entries :global(:not(.result-form) > .dialog-field-container) {
    margin-top: 0 !important;
  }
  .result-entries :global(.dialog-multiple) {
    padding-top: var(--entries-multiple-spacing, 1.5rem);
    padding-left: 0.8rem;
    padding-right: 2rem;
    padding-bottom: 0;
  }
  .result-entries :global(.dialog-multiple:first-child) {
    border-top: var(--top-entries-border, none);
    padding-top: var(--padding-between-borders-and-first-container) !important;
    & > .dialog-multiple-buttons {
      top: calc(var(--padding-between-borders-and-first-container) + var(--delete-button-offset));
    }
  }
  .result-entries :global(.dialog-multiple:last-of-type) {
    padding-bottom: var(--padding-between-last-container-and-borders) !important;
    border-bottom: var(--bottom-entries-border, none);
    margin-bottom: var(--margin-below-borders-and-buttons);
  }
  .result-entries :global(.dialog-multiple-buttons:not(.dialog-field-content > .dialog-multiple:first-child > div)) {
    top: var(--delete-button-top)
  }
  .result-entries :global(.dialog-multiple-buttons > button > svg) {
    color: var(--dg-button-bg);
  }
  .result-entries-record {
    display: flex;
  }
  .result-entries-record > .tooltipped :global(.dialog-field-container) {
    margin-bottom: 0 !important;
    & select {
      margin-bottom: 0 !important;
      padding: 0.2rem 0.5rem;
    }
    /*& > label {
      display: none;
    }*/
  }
  /* Search Words */
  .result-entries-record > .tooltipped:first-child {
    flex-grow: 1;
  }
  /* Mode */
  .result-entries-record > .tooltipped:nth-child(2) {
    width: 10rem;
  }
  /* Priority */
  .result-entries-record > .tooltipped:last-child {
    width: 8rem;
  }
  /* Spacing between the above inputs. */
  .result-entries-record > .tooltipped:not(:last-child) {
    margin-right: 0.5rem !important;
  }
  .submit-button {
    margin-bottom: 1rem;
  }
  .submit-button:disabled {
    margin-bottom: 1rem;
    color: black;
    background-color: var(--dg-button-disabled-bg);
    cursor: auto;
  }
</style>
