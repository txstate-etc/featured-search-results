<script lang='ts' context='module'>
  import type { TemplateResult, RawJsonResult, ResultFull } from '$lib/models/result.js'
  import type { PopupMenuItem } from '@txstate-mws/svelte-components'
  import { MessageType, type Feedback, type FormStore, type SubmitResponse } from '@txstate-mws/svelte-forms'
  import FeedbackLinks from './FeedbackLinks.svelte'
  import { VALIDATE_ONLY, apiURL, appURL } from '$lib/util/globals'
  import { isValidHttpUrl } from '$lib/util/helpers'
  import { FieldHidden, FieldNumber, FieldSelect, FieldStandard, FieldText, Form, Icon, Input } from '@dosgato/dialog'
  import FieldMultiple from './FieldMultiple.svelte'
  // import helpCircle from '@iconify-icons/mdi/help-circle'
  import deleteCircle from '@iconify-icons/mdi/delete'

  const equivUrlsRegex = /equivalent\.url\.(?<id>[^.]*)\.(?<title>.*)/
  const equivTitlesRegex = /equivalent\.title\.(?<id>[^.]*)\.(?<title>.*)/

  /**
  ```ts
  {
    url: string
    title: string
    id?: string
    entries: {
      keyphrase: string
      mode: 'keyword'|'phrase'|'exact'
      priority: number
    }[]
    tags?: string[]
    priority?: number
  }
  ``` */
  interface ResultState extends RawJsonResult {
    /** IDs are generated by Mongo/Mongoose and this serves as a placeholder when passed a list of
    entries to populate the form's entries section with for editing. */
    id?: string
  }
  const choices: PopupMenuItem[] = [
    { value: 'keyword', label: 'Keyword' },
    { value: 'phrase', label: 'Phrase' },
    { value: 'exact', label: 'Exact' }
  ]

  const keyphraseTooltip = 'The word, words, or phrase to find in the query.'
  const modeTooltip = `The type of matching to perform:
  Exact - Terms must exactly match the query.
  Phrase - Terms must be present in the query in the same order as here.
  Keyword - Terms must be present in the query in any order.`
  const priorityTooltip = 'Use a weight scale where 1 represents the lowest priority, 100 represents the highest priority, and reserve greater than 100 or less than 0 for extremely exceptional situations.'
</script>
<script lang='ts'>
  /* TODO:
    1) Fix submit errors. Done. - Need to work out asyoutype validations.
    2) Validate checks with fetches against API.
       - Started adding Feedbacks to API's handling. Still need to pass associated VALIDATE_ONLY param to calls when validating.
    3) Look into CSS nesting with (this is very low priority for now)
    OR Ignore below and just use SCSS.
      a) different CSS attribute selectors.
        Examples:
        - div[class~='classname'] - for 'classname' being any one of the space separated words in class attribute.
        - div[class|='classname'] - for class value starts with 'classname' optionally followed by hyphenated classname extensions `-.*`
        - div[class*='classname'] - for 'classname' being a substring contained anywhere in the class attribute.
      b) :has(), :is(), and :where() psuedo-selectors.
        Examples:
        - :global(.class1:not(:has(.subclass))) - For making clearer structure refrences.
        - :global(:is(.class1, .class2)) - For grouping common rules with most-specific specificity.
        - :global(:where(.class1, .class2)) - For grouping common rules with zero specificity.
    4) Add confirmation dialog when [Save] is pressed. Possibly the same when [Delete] is pressed
       if they want a [Delete] button for the entire Rusult record.
  */
  import { onMount } from 'svelte'

  /** A `TemplateResult` compatible object to preload the editor form with. */
  export let data: TemplateResult | undefined
  /** The API endpoint and method to submit the form data to. */
  export let apiTarget: { url: string, method: string } = { url: `${apiURL}/result`, method: 'POST' }

  const preload = data ?? {
    title: undefined,
    url: 'https://',
    entries: [
      { keyphrase: undefined, mode: 'keyword', priority: undefined }
    ]
  }

  let store: FormStore<ResultState>
  let tagsinputelement: HTMLInputElement = undefined as any

  async function submit (state: ResultState): Promise<SubmitResponse<ResultState>> {
    /* TODO:
      - Add confirmation dialog with possible diff resolve of record state. */
    const resp = await (await fetch(`${apiTarget.url}`, { method: apiTarget.method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(state) })).json()
    const messages = resp.messages ?? []
    if (messages.length > 0) {
      return { success: false, data: state, messages }
    } else messages.push({ type: MessageType.SUCCESS, message: 'Successfully saved.' })
    return { success: true, data: resp.result, messages }
  }

  async function validate (state: ResultState): Promise<Feedback[]> {
    const parsedURL = isValidHttpUrl(state.url) ? new URL(state.url) : undefined
    if (parsedURL) {
      const newUrl = /\/$/.test(state.url) ? parsedURL.toString() : parsedURL.toString().replace(/\/$/, '')
      await store.setField('url', newUrl)
    }
    const resp = await (await fetch(`${apiTarget.url}?${VALIDATE_ONLY}`, {
      method: apiTarget.method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(state)
    })).json() as ({ result: Partial<ResultFull>, messages: Feedback[] } | { message: string })
    /* For some reason the auto-validate first call to /result POST doens't have values for login.
     * Check for that response and don't validate further else we'll get all sorts of errors trying
     * to work with properties of undefined parents that the API didn't return because its first call
     * might not have thought we were logged in - May be a dev env only thing. */
    const thrownResp = resp as { message: string }
    if (thrownResp.message && thrownResp.message === 'Error: 403') {
      return [{ type: MessageType.WARNING, path: 'login', message: 'API was not able to identify you.' }]
    }
    const processedResp = resp as { result: Partial<ResultFull>, messages: Feedback[] }
    const messages: Feedback[] = processedResp.messages ?? []
    // Translate message paths to match our store's paths.
    return messages.map(m => ({ ...m, path: m.path?.replace(/keywords/, 'keyphrase') }))
  }

  function tagsSerialize (value: string[]) {
    return value?.join(' ') ?? ''
  }
  function tagsDeserialize (value: string) {
    return value?.split(/[, ]/) ?? []
  }
  function lowercaseSerialize (value: string) {
    return value?.toLowerCase() ?? ''
  }


  onMount(() => {
    /* Remove the empty label from FieldMultiple. */
    // Array.from(entries.getElementsByTagName('label')).filter(l => isBlank(l.textContent)).forEach(e => { e.remove() })
  })
  $: submitContext = data?.id ? 'Update' : 'Create'
</script>
<!--
  @component
  TODO: Add reference description for component that's displayed in VSCode editors.
-->

<Form bind:store name='result' {submit} {validate} {preload} let:saved let:messages>
  <div class='result-form'>
    <FieldText path='title' label='Display Title:' defaultValue={''} required/>
    <FeedbackLinks data={messages} path={equivTitlesRegex} targetURL={`${appURL}/results/`} pathKeys={['id', 'title']}
      buildPath={(found, keys) => found.id} preamble='Edit ' getText={(found, keys) => found.title} postscript="'s record."/>
    <FieldText path='url' label='Target URL:' defaultValue={'https://'} required />
    <FeedbackLinks data={messages} path={equivUrlsRegex} targetURL={`${appURL}/results/`} pathKeys={['id', 'title']}
      buildPath={(found, keys) => found.id} preamble='Edit ' getText={(found, keys) => found.title} postscript="'s record."/>
    <!-- svelte-forms(entries[]) -->
    <div class='result-entries'>
      <!--
      <div class='label-with-helpicon'>
        <label for={'alias-help'}>Matching Aliases</label>
        <button id='alias-help' type='button' on:click|preventDefault|stopPropagation={openHelp}>
          <Icon icon={helpCircle} hiddenLabel='documentation on search result aliases'/>
        </button>
      </div>
      -->
      <FieldMultiple path='entries' label='Matchings' helptext='' removable={true} let:index>
        <div class='result-entries-record'>
          <span data-tooltip={keyphraseTooltip} class={index === 0 ? 'tooltip-shown tooltipped' : 'tooltipped'}>
            <FieldText path='keyphrase' label='Terms:' defaultValue={''} required />
          </span>
          <span data-tooltip={modeTooltip} class={index === 0 ? 'tooltip-shown tooltipped' : 'tooltipped'}>
            <FieldSelect path='mode' label='Type:' notNull defaultValue={'keyword'} {choices} required />
          </span>
          <span data-tooltip={priorityTooltip} class={index === 0 ? 'tooltip-shown tooltipped' : 'tooltipped'}>
            <FieldNumber path='priority' label='Weight:' defaultValue={50} step={10} required/>
          </span>
        </div>
        <Icon slot='removeBtnIcon' icon={deleteCircle} hiddenLabel='remove from list'/>
      </FieldMultiple>
    </div>
    <FieldStandard path='tags' label='Administrative Tags:' defaultValue={''} serialize={tagsSerialize} deserialize={tagsDeserialize} let:value let:valid let:invalid let:id let:onBlur let:onChange let:messagesid let:helptextid>
      <Input bind:inputelement={tagsinputelement} name='tags' {value} {id} class="dialog-input" {onChange} {onBlur} {valid} {invalid} {messagesid} {helptextid} ></Input>
    </FieldStandard>
  </div>
  {#if data?.id}<FieldHidden path='id' bind:value={data.id}/>{/if}
  <svelte:fragment slot='submit' let:saved let:submitting let:validating let:valid let:invalid let:messages>
    <button on:click class='submit-button' style={`--submit-context: '${submitContext}';`}
      class:validating class:submitting class:saved type='submit' disabled={!valid}>
      {#if submitting}Submitting...
      {:else if validating}Validating...
      {:else if saved}<span></span>
      {:else}{submitContext}
      {/if}
    </button>
  </svelte:fragment>
</Form>

<!-- <style lang="scss"> TODO: I need to get back to translating the below to scss. Lower priority right now. -->
<style>
  .tooltipped {
    position: relative;
  }
  .tooltip-shown::before { /* Text */
    content: attr(data-tooltip);
    text-align: center;
    font-size: medium;
    white-space: pre-wrap;
    width: max-content;
    max-width: 200%;
    --scale: 0;
    position: absolute;
    top: -.25rem;
    left: -3rem;
    transform: translateX(-1rem) translateY(-90%) scale(var(--scale));
    transition: 50ms transform ease-in-out;
    transform-origin: bottom center;
    padding: 0.2rem 0.5rem;
    /* border: .25rem solid transparent; */
    border-radius: .3rem;
    background-color: var(--colors-help);
    color: var(--colors-help-text);
    z-index: 1;
  }
  .tooltip-shown:first-child::before {
    left: 0;
    transform: translateX(-.5rem) translateY(-90%) scale(var(--scale));
  }
  .tooltip-shown:nth-child(2)::before {
    text-align: left;
    left: -7rem;
    max-width: 300%;
  }
  .tooltip-shown:hover::before {
    --scale: 1;
  }
  .submit-button.saved > span::after {
    content: 'Successful!';
    animation: replace normal forwards 10s;
  }
  @keyframes replace {
    to { content: var(--submit-context); }
  }
  .result-form {
    --entries-multiple-spacing: 1.0rem;/*var(--element-container-spacing);   They liked 1.5rem. */
    --padding-between-borders-and-first-container: calc(var(--entries-multiple-spacing) - 0.3rem);
    --padding-between-last-container-and-borders: var(--entries-multiple-spacing);
    --margin-below-borders-and-buttons: calc(var(--margin-below-labels) + 0.1rem);
    --container-borders: 1px solid black;
    --delete-button-offset: 1.3rem;
    --delete-button-top: calc(var(--entries-multiple-spacing) + var(--delete-button-offset));
    --help-icon-size: 0.7rem;
    --border-to-label-spacing: 0.8rem;
    & > div:not(.result-entries) {
      border: none !important;
    }
    & > div:last-of-type {
      margin-bottom: var(--element-container-spacing);
    }
  }
  .result-form :global(.dialog-multiple) {
    --dialog-container-border: none;
    border: none;
  }
  /* All form containers except those nested under result-entries. */
  .result-form :global(.dialog-field-container:not(.result-entries *)) {
    padding: 0 !important;
    margin-top: var(--element-container-spacing);
    & > label {
      margin-bottom: var(--margin-below-labels);
    }
  }
  .result-entries {
    margin-top: var(--element-container-spacing);
    border-top: var(--container-borders);
    padding-top: var(--border-to-label-spacing);
    padding-bottom: var(--element-container-spacing);
    border-bottom: var(--container-borders);
  }
  /* .label-with-helpicon {
    & > label {
      display: inline-block;
      padding-right: 0;
      margin-bottom: var(--margin-below-labels);
    }
    & > button {
      border: none;
      background: transparent;
      padding: 0;
      cursor: pointer;
      font-size: 1.3rem;
    }
  }
  .label-with-helpicon > button :global(svg) {
    display: inline-block;
    box-sizing: border-box;
    width: var(--help-icon-size);
    height: var(--help-icon-size);
    color: var(--colors-help);
  } */
  .result-entries :global(.dialog-field-container) {
    padding: 0 !important;
  }
  .result-entries :global(:not(.result-form) > .dialog-field-container) {
    margin-top: 0 !important;
  }
  .result-entries :global(.dialog-multiple) {
    padding-top: var(--entries-multiple-spacing, 1.5rem);
    padding-left: 0.8rem;
    padding-right: 2rem;
    padding-bottom: 0;
  }
  .result-entries :global(.dialog-multiple:first-child) {
    border-top: var(--top-entries-border, none);
    padding-top: var(--padding-between-borders-and-first-container) !important;
    & > .dialog-multiple-buttons {
      top: calc(var(--padding-between-borders-and-first-container) + var(--delete-button-offset));
    }
  }
  .result-entries :global(.dialog-multiple:last-of-type) {
    padding-bottom: var(--padding-between-last-container-and-borders) !important;
    border-bottom: var(--bottom-entries-border, none);
    margin-bottom: var(--margin-below-borders-and-buttons);
  }
  .result-entries :global(.dialog-multiple-buttons:not(.dialog-field-content > .dialog-multiple:first-child > div)) {
    top: var(--delete-button-top)
  }
  .result-entries :global(.dialog-multiple-buttons > button > svg) {
    color: var(--dg-button-bg);
  }
  .result-entries-record {
    display: flex;
  }
  .result-entries-record > .tooltipped :global(.dialog-field-container) {
    margin-bottom: 0 !important;
    & select {
      margin-bottom: 0 !important;
      padding: 0.2rem 0.5rem;
    }
    /*& > label {
      display: none;
    }*/
  }
  /* Search Words */
  .result-entries-record > .tooltipped:first-child {
    flex-grow: 1;
  }
  /* Mode */
  .result-entries-record > .tooltipped:nth-child(2) {
    width: 10rem;
  }
  /* Priority */
  .result-entries-record > .tooltipped:last-child {
    width: 8rem;
  }
  /* Spacing between the above inputs. */
  .result-entries-record > .tooltipped:not(:last-child) {
    margin-right: 0.5rem !important;
  }
  .submit-button {
    margin-bottom: 1rem;
  }
  .submit-button:disabled {
    margin-bottom: 1rem;
    color: black;
    background-color: var(--dg-button-disabled-bg);
    cursor: auto;
  }
</style>
